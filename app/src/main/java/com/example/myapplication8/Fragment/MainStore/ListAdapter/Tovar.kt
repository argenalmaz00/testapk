package com.example.myapplication8.Fragment.MainStore.ListAdapter

import com.example.myapplication8.R
import kotlin.random.Random

class Tovar {
    private val list = ArrayList<TovarClass>()
    private val img = listOf<Int>(R.drawable.cpu,
        R.drawable.edaone,
        R.drawable.games,
        R.drawable.gamesdoc,
        R.drawable.rtx,
        R.drawable.hotdoc,
        R.drawable.tanks,
        R.drawable.teddies,
        R.drawable.odezda,
        R.drawable.tankrus,
        R.drawable.samykh,
        R.drawable.irapots,
        R.drawable.kinodisk,
        R.drawable.ladasidan,
        )
    private val descriptions = listOf<String>("Тут нужно пояснить, что задачи с наивысшим приоритетом, могут пользователи только с правами root. Если мы бы попытались сделать из-под обычного пользователя, то ничего у нас бы не вышло.\n" +
            "\n" +
            "killall sleep, еще раз завершим принудительно процессы. Запустим еще раз процесс с наименьшим приоритетом. nice -n 19 sleep 60000. Теперь изменим приоритет текущего процесса. Для этого есть следующая команда:",
    "OpenVPN проводит все сетевые операции через TCP- или UDP-транспорт. В общем случае предпочтительным является UDP по той причине, что через туннель проходит трафик сетевого уровня и выше по OSI, если используется TUN-соединение, или трафик канального уровня и выше, если используется TAP. Это значит, что OpenVPN для клиента выступает протоколом канального или даже физического уровня, а значит, надежность передачи данных может обеспечиваться вышестоящими по OSI уровнями, если это необходимо. Именно поэтому протокол UDP по своей концепции наиболее близок к OpenVPN, т. к. он, как и протоколы канального и физического уровней, не обеспечивает надежности соединения, передавая эту инициативу более высоким уровням. Если же настроить туннель на работу по ТСР, сервер в типичном случае будет получать ТСР-сегменты OpenVPN, которые содержат другие ТСР-сегменты от клиента. В результате в цепи получается двойная проверка на целостность информации, что совершенно не имеет смысла, т. к. надежность не повышается, а скорости соединения и пинга снижаются.[8][9]. Также возможна работа через большую часть прокси-серверов, включая HTTP, SOCKS, через NAT и сетевые фильтры. Сервер может быть настроен на назначение сетевых настроек клиенту. Например: IP-адрес, настройки маршрутизации и параметры соединения. OpenVPN предлагает два различных варианта сетевых интерфейсов, используя драйвер TUN/TAP. Возможно создать туннель сетевого уровня, называемый TUN, и канального уровня — TAP, способный передавать Ethernet-трафик. Также возможно использование библиотеки компрессии LZO для сжатия потока данных. Используемый порт 1194 выделен Internet Assigned Numbers Authority для работы данной программы[10]. Версия 2.0 позволяет одновременно управлять несколькими туннелями в отличие от версии 1.0, позволявшей создавать только 1 туннель на 1 процесс.",
    "OpenVPN — свободная реализация технологии виртуальной частной сети (VPN) с открытым исходным кодом для создания зашифрованных каналoв типа точка-точка или сервер-клиенты между компьютерами. Она позволяет устанавливать соединения между компьютерами, находящимися за NAT и сетевым экраном, без необходимости изменения их настроек. OpenVPN была создана Джеймсом Йонаном (James Yonan) и распространяется под лицензией GNU")
    fun getDataTovar() :ArrayList<TovarClass>{

        for (i in 0..20){
            list.add(TovarClass(img[Random.nextInt(0,img.size)],"test","12-10-2012","${descriptions[Random.nextInt(0,descriptions.size)]}"))
        }
        return list
    }
}